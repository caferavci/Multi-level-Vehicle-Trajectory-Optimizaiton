# -*- coding: utf-8 -*-
"""Untitled88.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/186LUmFiAYR16X9SDVkxX8aCCzvVqjStK
"""

# ===========================================
#  dp_micro_cost.py  –  Part‑B style DP demo
# ===========================================
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.io import loadmat

# ---------- 1. Load the 0-th lane-change trajectory ----------
MAT = 'lc_data_20s_withpoints.mat'; IDX = 0
mat = loadmat(MAT, struct_as_record=False, squeeze_me=True)
sc  = mat['lc_data'][IDX]; pts = float(mat['points'][IDX,1])
sub_y = sc.veh_s.y[:200]
sub_v = sc.veh_s.v[:200]
sub_a = sc.veh_s.a[:200]
front_y, front_v = sc.veh_ft.y[:200], sc.veh_ft.v[:200]
rear_y           = sc.veh_rt.y[:200]  # Only for rear-end safety check
L, dt = len(sub_v), 0.1
t = np.arange(L) * dt
h_ss = pts / 10.0    # (Eq. 7) steady-state headway
v_ss = 6.0           # Set steady-state speed 6 m/s

# ---------- 2. DP state discretization ----------
v_min, v_max, dv = 0., 15., 0.25
h_min, h_max, dh = 0., 48., 0.5
vg = np.arange(v_min, v_max + 1e-9, dv)
hg = np.arange(h_min, h_max + 1e-9, dh)
Nv, Nh = len(vg), len(hg)
rho_set = np.linspace(0, 1, 11)

# ---------- 3. Weights & physical constraints ----------
Kh, Kv = 1.0, 1.0          # (Eq. 10) gains
wa, wv, wh, w_rho = 1.0, 1.0, 1.0, 0.1   # stage-cost weights
a_min, a_max = -3.5, 3.5   # acceleration limits

# ---------- 4. Initialize DP cost array ----------
J = np.full((L, Nv, Nh), np.inf)
PI = np.full((L-1, Nv, Nh), -1, dtype=int)
for vi, v in enumerate(vg):
    for hi, h in enumerate(hg):
        J[-1, vi, hi] = wh * (h_ss - h)**2 + wv * (v_ss - v)**2  # terminal cost

front_gap = front_y - rear_y  # Used for rear-end safety

# ---------- 5. Backward DP (Eq. 26‑28) ----------
for k in range(L-2, -1, -1):  # time k
    for vi, v in enumerate(vg):
        for hi, h in enumerate(hg):
            best = np.inf; best_u = -1
            for ui, rho in enumerate(rho_set):
                # (10) a = ρ Kh ΔH + (1-ρ) Kv Δv
                a = rho * Kh * (h - h_ss) + (1 - rho) * Kv * (v_ss - v)
                a = np.clip(a, a_min, a_max)
                v2 = np.clip(v + a * dt, v_min, v_max)
                h2 = np.clip(h + (front_v[k] - v) * dt, h_min, h_max)
                if h2 > front_gap[k]:
                    continue  # rear-end safety
                vi2 = int(round((v2 - v_min) / dv)); vi2 = np.clip(vi2, 0, Nv-1)
                hi2 = int(round((h2 - h_min) / dh)); hi2 = np.clip(hi2, 0, Nh-1)
                # stage cost: λ_a a² + λ_v Δv² + λ_h ΔH² + λ_ρ ρ²
                cost = wa * a * a + wv * (v_ss - v) ** 2 + wh * (h_ss - h) ** 2 + w_rho * rho * rho
                tot = cost + J[k+1, vi2, hi2]
                if tot < best:
                    best, best_u = tot, ui
            J[k, vi, hi] = best
            PI[k, vi, hi] = best_u

# ---------- 6. Forward rollout to get optimal trajectory ----------
v, h = sub_v[0], front_y[0] - sub_y[0]
opt_v, opt_h, opt_a, opt_rho = [v], [h], [], []
for k in range(L-1):
    vi = int(round((v - v_min) / dv)); hi = int(round((h - h_min) / dh))
    ui = PI[k, vi, hi]; rho = rho_set[ui]
    a = np.clip(rho * Kh * (h - h_ss) + (1 - rho) * Kv * (v_ss - v), a_min, a_max)
    v = np.clip(v + a * dt, v_min, v_max)
    h = np.clip(h + (front_v[k] - v) * dt, h_min, h_max)
    opt_v.append(v)
    opt_h.append(h)
    opt_a.append(a)
    opt_rho.append(rho)

opt_v, opt_h, opt_a, opt_rho = map(np.array, [opt_v, opt_h, opt_a, opt_rho])

# ---------- 7. Cost breakdown (Fig.) ----------
cost_a = wa * opt_a ** 2
cost_v = wv * (v_ss - opt_v[:-1]) ** 2
cost_h = wh * (h_ss - opt_h[:-1]) ** 2
norm_a = cost_a / cost_a.max()
norm_v = cost_v / cost_v.max()
norm_h = cost_h / cost_h.max()

plt.figure(figsize=(6, 5))
plt.subplot(2, 1, 1)
plt.plot(t[:-1], norm_a, 'r-', label='a² (norm)')
plt.plot(t[:-1], norm_v, 'g--', label='Speed err² (norm)')
plt.plot(t[:-1], norm_h, 'b:', label='ΔH² (norm)')
plt.title('Instantaneous Cost Breakdown (normalized)')
plt.ylabel('Normalized cost')
plt.legend()
plt.grid(alpha=.3)
plt.subplot(2, 1, 2)
plt.plot(t[:-1], np.cumsum(cost_a), 'r-', label='Σ a²')
plt.plot(t[:-1], np.cumsum(cost_v), 'g--', label='Σ Speed err²')
plt.plot(t[:-1], np.cumsum(cost_h), 'b:', label='Σ ΔH²')
plt.xlabel('Time (s)')
plt.ylabel('Cumulative cost')
plt.title('Cumulative Cost Contribution')
plt.legend()
plt.grid(alpha=.3)
plt.tight_layout()
plt.savefig('cost_breakdown.png', dpi=300)

# ---------- 8. Additional micro-level figures ----------
# 8-1. Smoothed ρ(t)
rho_s = pd.Series(opt_rho).rolling(3, center=True).mean().bfill().ffill()
plt.figure(figsize=(6, 2.8))
plt.step(t[:-1], rho_s, where='mid')
plt.ylim(0, 1.05)
plt.xlabel('Time (s)')
plt.ylabel('ρ(t)')
plt.title('Optimal ρ*(t)')
plt.grid(alpha=.3)
plt.tight_layout()
plt.savefig('rho_sequence.png', dpi=300)

# 8-2. ΔH(t)
plt.figure(figsize=(6, 2.8))
plt.plot(t, h_ss - (front_y - sub_y), 'k--', label='Original')
plt.plot(t, h_ss - opt_h, 'r-', label='Optimal')
plt.axhline(0, color='grey', lw=.5)
plt.legend()
plt.xlabel('Time (s)')
plt.ylabel('ΔH (m)')
plt.title('Headway Error ΔH(t)')
plt.grid(alpha=.3)
plt.tight_layout()
plt.savefig('deltaH.png', dpi=300)

# 8-3. x-v-a triple comparison
x_opt = np.cumsum(opt_v * dt) + sub_y[0]
fig, ax = plt.subplots(3, 1, figsize=(6, 7), sharex=True)
ax[0].plot(t, sub_y, 'b--')
ax[0].plot(t, x_opt, 'r-')
ax[0].set_ylabel('x (m)')
ax[1].plot(t, sub_v, 'b--')
ax[1].plot(t, opt_v, 'r-')
ax[1].set_ylabel('v (m/s)')
ax[2].plot(t, sub_a, 'b--')
ax[2].plot(t[:-1], opt_a, 'r-')
ax[2].set_ylabel('a (m/s²)')
ax[2].set_xlabel('Time (s)')
for a in ax:
    a.grid(alpha=.3)
plt.tight_layout()
plt.savefig('traj_compare.png', dpi=300)

print('Finished. 4 figures generated:\n  traj_compare.png  deltaH.png\n  rho_sequence.png  cost_breakdown.png')